#!/usr/bin/env python3
"""
git Plugin

Auto-generated plugin for git command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import subprocess
import sys
import time
from typing import Dict, Any


def run(args: Dict[str, Any], dry_run: bool = False) -> Dict[str, Any]:
    """Execute the git command."""
    try:
        # Build command arguments
        cmd_args = ["git"]
        pass
        if args.get("command") is not None:
            value = args["command"]
            if isinstance(value, str) and " " in value:
                # Split string on spaces to handle multiple tokens (e.g., "repo list owner --limit 110")
                cmd_args.extend(value.split())
            else:
                cmd_args.append(str(value))
        if args.get("args"):
            value = args["args"]
            if isinstance(value, list):
                cmd_args.extend([str(v) for v in value])
            elif isinstance(value, str) and " " in value:
                # Split string on spaces to handle multiple tokens (e.g., "repo list owner --limit 110")
                cmd_args.extend(value.split())
            else:
                cmd_args.append(str(value))
        
        # Dry run mode: return what would be executed without running
        if dry_run:
            return {
                "dry_run": True,
                "command": " ".join(cmd_args),
                "cmd_args": cmd_args,
                "args_received": args
            }
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=30
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        # Always pass through output (stdout and/or stderr) regardless of return code
        # This allows commands like 'git' and 'gh' to show help even with non-zero exit codes
        # Combine stdout and stderr for complete output visibility
        output_parts = []
        if result.stdout:
            output_parts.append(result.stdout)
        if result.stderr:
            output_parts.append(result.stderr)
        output = '\n'.join(output_parts) if output_parts else ''
        
        # Always include both stdout and stderr in response for debugging
        response = {
            "command": " ".join(cmd_args),
            "return_code": result.returncode,
            "elapsed": elapsed
        }
        
        if result.stdout:
            response["stdout"] = result.stdout
        if result.stderr:
            response["stderr"] = result.stderr
        
        if result.returncode == 0:
            # Success: use "result" field with combined output
            response["result"] = output if output else "Command completed successfully"
            return response
        else:
            # Non-zero return code: still pass through output in "result" field
            # Only use "error" if there's no output at all
            if output:
                response["result"] = output
                return response
            else:
                response["error"] = f"Command failed with return code {result.returncode} (no output)"
                return response
        
    except subprocess.TimeoutExpired:
        return {
            "error": "Command timed out after 30 seconds"
        }
    except Exception as e:
        return {
            "error": f"Command execution failed: {str(e)}"
        }


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {
        "plugin": {
            "name": "git",
            "version": "1.0.0",
            "description": "Auto-generated plugin for git command"
        },
        "commands": [
            {
                "name": "run",
                "description": "Execute the git command",
                "parameters": [
                    {
                        "name": "command",
                        "type": "string",
                        "description": "COMMAND argument",
                        "required": False,
                        "default": None
                    },
                    {
                        "name": "args",
                        "type": "string",
                        "description": "ARGS argument",
                        "required": False,
                        "default": None
                    }
                ]
            }
        ]
    }


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="git Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the git command

Examples:
  python cli.py run --command <value> --args <value>
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute git command")
    run_parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Show what would be executed without running")
    pass
    run_parser.add_argument("--command", dest="arg_command", help="COMMAND argument")
    run_parser.add_argument("--args", nargs="*", dest="arg_args", help="ARGS argument (optional)")
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Check for dry-run flag
            dry_run = getattr(args, 'dry_run', False)
            
            # Convert argparse args to dict for run function
            run_args = {}
            if hasattr(args, "arg_command") and args.arg_command is not None:
                run_args["command"] = args.arg_command
            if hasattr(args, "arg_args") and args.arg_args is not None:
                run_args["args"] = args.arg_args
            # Always call run, even with no args (to show gh help)
            result = run(run_args, dry_run=dry_run)
        else:
            result = {"error": f"Unknown command: {args.command}"}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)


if __name__ == "__main__":
    main()
