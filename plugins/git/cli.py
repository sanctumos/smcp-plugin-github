#!/usr/bin/env python3
"""
git Plugin

Auto-generated plugin for git command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import os
import shlex
import subprocess
import sys
import time
from typing import Dict, Any, Optional


def run(args: Dict[str, Any], dry_run: bool = False, non_interactive: bool = False, cwd: Optional[str] = None) -> Dict[str, Any]:
    """Execute the git command."""
    try:
        # Validate working directory if specified (fixes issue #3)
        if cwd is not None:
            if not os.path.isdir(cwd):
                return {
                    "error": f"Working directory does not exist: {cwd}"
                }
            cwd = os.path.abspath(cwd)
        
        # Build command arguments
        cmd_args = ["git"]
        pass
        if args.get("command") is not None:
            value = args["command"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        if args.get("args"):
            value = args["args"]
            if isinstance(value, list):
                cmd_args.extend([str(v) for v in value])
            elif isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        
        # Add --yes flag for non-interactive mode (fixes issue #2)
        if non_interactive and "--yes" not in cmd_args and "-y" not in cmd_args:
            cmd_args.append("--yes")
        
        # Dry run mode: return what would be executed without running
        if dry_run:
            return {
                "dry_run": True,
                "command": " ".join(cmd_args),
                "cmd_args": cmd_args,
                "args_received": args,
                "cwd": cwd
            }
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=30,
            cwd=cwd
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        # Always pass through output (stdout and/or stderr) regardless of return code
        # This allows commands like 'git' and 'gh' to show help even with non-zero exit codes
        # Combine stdout and stderr for complete output visibility
        output_parts = []
        if result.stdout:
            output_parts.append(result.stdout)
        if result.stderr:
            output_parts.append(result.stderr)
        output = '\n'.join(output_parts) if output_parts else ''
        
        # Build command string for error context (fixes issue #6)
        command_str = " ".join(cmd_args)
        
        # Always include both stdout and stderr in response for debugging
        response = {
            "command": command_str,
            "return_code": result.returncode,
            "elapsed": elapsed
        }
        
        if result.stdout:
            response["stdout"] = result.stdout
        if result.stderr:
            response["stderr"] = result.stderr
        
        if result.returncode == 0:
            # Success: use "result" field with combined output
            response["result"] = output if output else "Command completed successfully"
            return response
        else:
            # Non-zero return code: enhance error messages with context (fixes issue #6)
            if output:
                response["result"] = output
                # Add error analysis for common patterns
                error_hints = _analyze_error(result.stderr, command_str, cwd)
                if error_hints:
                    response["error_hints"] = error_hints
                return response
            else:
                # No output but command failed - provide context
                error_msg = f"Command failed with return code {result.returncode} (no output)"
                if cwd:
                    error_msg += f" in directory: {cwd}"
                response["error"] = error_msg
                response["return_code"] = result.returncode  # Always include return_code
                response["command_context"] = {
                    "command": command_str,
                    "cwd": cwd,
                    "args_received": args
                }
                return response
        
    except subprocess.TimeoutExpired:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "git [command]"
        return {
            "error": f"Command timed out after 30 seconds",
            "command": command_str,
            "error_type": "timeout",
            "suggestion": "The command may be waiting for input or taking too long. Try using --non-interactive flag or check network connectivity."
        }
    except Exception as e:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "git [command]"
        return {
            "error": f"Command execution failed: {str(e)}",
            "command": command_str,
            "error_type": "execution_error",
            "command_context": {
                "args_received": args,
                "cwd": cwd
            }
        }


def _analyze_error(stderr: str, command: str, cwd: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """Analyze stderr for common error patterns and provide helpful hints (fixes issue #6)."""
    if not stderr:
        return None
    
    hints = {}
    stderr_lower = stderr.lower()
    
    # Git repository errors
    if "not a git repository" in stderr_lower or "fatal: not a git repository" in stderr_lower:
        hints["error_type"] = "git_repository_error"
        suggestions = ["Ensure you're in a git repository directory"]
        if cwd:
            suggestions.append(f"Current directory: {cwd}")
        else:
            suggestions.append("Consider using --cwd flag to specify the repository directory")
        hints["suggestions"] = suggestions
    
    # Commit/ref errors
    elif "no commit found" in stderr_lower or "could not resolve" in stderr_lower or "unknown revision" in stderr_lower:
        hints["error_type"] = "reference_error"
        hints["suggestions"] = [
            "Check that the branch, tag, or commit reference exists",
            "Verify the reference name is correct",
            "Try 'git branch -a' or 'git tag -l' to list available references"
        ]
    
    # Remote/network errors
    elif "could not read from remote" in stderr_lower or "failed to push" in stderr_lower:
        hints["error_type"] = "remote_error"
        hints["suggestions"] = [
            "Check network connectivity",
            "Verify remote URL is correct: 'git remote -v'",
            "Check authentication for the remote repository"
        ]
    
    # Merge/conflict errors
    elif "merge conflict" in stderr_lower or "conflicts" in stderr_lower:
        hints["error_type"] = "merge_error"
        hints["suggestions"] = [
            "Resolve merge conflicts in the affected files",
            "Use 'git status' to see conflicted files",
            "After resolving, stage files with 'git add' and commit"
        ]
    
    # Permission errors
    elif "permission denied" in stderr_lower:
        hints["error_type"] = "permission_error"
        hints["suggestions"] = [
            "Check file/directory permissions",
            "Ensure you have write access to the repository"
        ]
    
    if hints:
        return hints
    return None


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {
        "plugin": {
            "name": "git",
            "version": "1.0.0",
            "description": "Auto-generated plugin for git command"
        },
        "commands": [
            {
                "name": "run",
                "description": "Execute the git command",
                "parameters": [
                    {
                        "name": "command",
                        "type": "string",
                        "description": "COMMAND argument",
                        "required": False,
                        "default": None
                    },
                    {
                        "name": "args",
                        "type": "string",
                        "description": "ARGS argument",
                        "required": False,
                        "default": None
                    }
                ]
            }
        ]
    }


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="git Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the git command

Examples:
  python cli.py run --command <value> --args <value>
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute git command")
    run_parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Show what would be executed without running")
    run_parser.add_argument("--non-interactive", action="store_true", dest="non_interactive", help="Automatically add --yes flag for non-interactive execution")
    run_parser.add_argument("--cwd", dest="cwd", help="Change working directory for command execution")
    pass
    run_parser.add_argument("--command", dest="arg_command", help="COMMAND argument")
    run_parser.add_argument("--args", nargs="*", dest="arg_args", help="ARGS argument (optional)")
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Check for dry-run, non-interactive, and cwd flags
            dry_run = getattr(args, 'dry_run', False)
            non_interactive = getattr(args, 'non_interactive', False)
            cwd = getattr(args, 'cwd', None)
            
            # Convert argparse args to dict for run function
            run_args = {}
            if hasattr(args, "arg_command") and args.arg_command is not None:
                run_args["command"] = args.arg_command
            if hasattr(args, "arg_args") and args.arg_args is not None:
                run_args["args"] = args.arg_args
            # Always call run, even with no args (to show gh help)
            result = run(run_args, dry_run=dry_run, non_interactive=non_interactive, cwd=cwd)
        else:
            result = {"error": f"Unknown command: {args.command}"}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)


if __name__ == "__main__":
    main()
