#!/usr/bin/env python3
"""
gh Plugin

Auto-generated plugin for gh command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import shlex
import subprocess
import sys
import time
from typing import Dict, Any


def run(args: Dict[str, Any], dry_run: bool = False) -> Dict[str, Any]:
    """Execute the gh command."""
    try:
        # Build command arguments
        cmd_args = ["gh"]
        pass
        if args.get("command") is not None:
            value = args["command"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        if args.get("subcommand") is not None:
            value = args["subcommand"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        
        # Dry run mode: return what would be executed without running
        if dry_run:
            return {
                "dry_run": True,
                "command": " ".join(cmd_args),
                "cmd_args": cmd_args,
                "args_received": args
            }
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=30
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        # Always pass through output (stdout and/or stderr) regardless of return code
        # This allows commands like 'git' and 'gh' to show help even with non-zero exit codes
        # Combine stdout and stderr for complete output visibility
        output_parts = []
        if result.stdout:
            output_parts.append(result.stdout)
        if result.stderr:
            output_parts.append(result.stderr)
        output = '\n'.join(output_parts) if output_parts else ''
        
        # Always include both stdout and stderr in response for debugging
        response = {
            "command": " ".join(cmd_args),
            "return_code": result.returncode,
            "elapsed": elapsed
        }
        
        if result.stdout:
            response["stdout"] = result.stdout
        if result.stderr:
            response["stderr"] = result.stderr
        
        if result.returncode == 0:
            # Success: use "result" field with combined output
            response["result"] = output if output else "Command completed successfully"
            return response
        else:
            # Non-zero return code: still pass through output in "result" field
            # Only use "error" if there's no output at all
            if output:
                response["result"] = output
                return response
            else:
                response["error"] = f"Command failed with return code {result.returncode} (no output)"
                return response
        
    except subprocess.TimeoutExpired:
        return {
            "error": "Command timed out after 30 seconds"
        }
    except Exception as e:
        return {
            "error": f"Command execution failed: {str(e)}"
        }


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {
        "plugin": {
            "name": "gh",
            "version": "1.0.0",
            "description": "Auto-generated plugin for gh command"
        },
        "commands": [
            {
                "name": "run",
                "description": "Execute the gh command",
                "parameters": [
                    {
                        "name": "command",
                        "type": "string",
                        "description": "COMMAND argument",
                        "required": False,
                        "default": None
                    },
                    {
                        "name": "subcommand",
                        "type": "string",
                        "description": "SUBCOMMAND argument",
                        "required": False,
                        "default": None
                    }
                ]
            }
        ]
    }


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="gh Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the gh command

Examples:
  python cli.py run --command <value> --subcommand <value>
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute gh command")
    run_parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Show what would be executed without running")
    pass
    run_parser.add_argument("--command", dest="arg_command", help="COMMAND argument")
    run_parser.add_argument("--subcommand", dest="arg_subcommand", help="SUBCOMMAND argument")
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Check for dry-run flag
            dry_run = getattr(args, 'dry_run', False)
            
            # Convert argparse args to dict for run function
            run_args = {}
            if hasattr(args, "arg_command") and args.arg_command is not None:
                run_args["command"] = args.arg_command
            if hasattr(args, "arg_subcommand") and args.arg_subcommand is not None:
                run_args["subcommand"] = args.arg_subcommand
            # Always call run, even with no args (to show gh help)
            result = run(run_args, dry_run=dry_run)
        else:
            result = {"error": f"Unknown command: {args.command}"}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)


if __name__ == "__main__":
    main()
