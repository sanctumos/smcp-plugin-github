#!/usr/bin/env python3
"""
gh Plugin

Auto-generated plugin for gh command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import os
import shlex
import subprocess
import sys
import time
from typing import Dict, Any, Optional


def run(args: Dict[str, Any], dry_run: bool = False, non_interactive: bool = False, cwd: Optional[str] = None) -> Dict[str, Any]:
    """Execute the gh command."""
    try:
        # Validate working directory if specified (fixes issue #3, #9)
        if cwd is not None:
            if not os.path.isdir(cwd):
                return {
                    "success": False,
                    "error": f"Working directory does not exist: {cwd}",
                    "error_code": "INVALID_CWD"
                }
            cwd = os.path.abspath(cwd)
        
        # Build command arguments
        cmd_args = ["gh"]
        pass
        if args.get("command") is not None:
            value = args["command"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        if args.get("subcommand") is not None:
            value = args["subcommand"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        
        # Add --yes flag for non-interactive mode (fixes issue #2)
        if non_interactive and "--yes" not in cmd_args and "-y" not in cmd_args:
            cmd_args.append("--yes")
        
        # Dry run mode: return what would be executed without running
        if dry_run:
            return {
                "dry_run": True,
                "command": " ".join(cmd_args),
                "cmd_args": cmd_args,
                "args_received": args,
                "cwd": cwd
            }
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=30,
            cwd=cwd
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        # Always pass through output (stdout and/or stderr) regardless of return code
        # This allows commands like 'git' and 'gh' to show help even with non-zero exit codes
        # Combine stdout and stderr for complete output visibility
        output_parts = []
        if result.stdout:
            output_parts.append(result.stdout)
        if result.stderr:
            output_parts.append(result.stderr)
        output = '\n'.join(output_parts) if output_parts else ''
        
        # Build command string for error context (fixes issue #6)
        command_str = " ".join(cmd_args)
        
        # Always include both stdout and stderr in response for debugging
        response = {
            "command": command_str,
            "return_code": result.returncode,
            "elapsed": elapsed
        }
        
        if result.stdout:
            response["stdout"] = result.stdout
        if result.stderr:
            response["stderr"] = result.stderr
        
        # Check for idempotent scenarios (fixes issue #10)
        idempotent_info = _check_idempotency(result, command_str)
        
        # Standardize response format (fixes issue #9)
        response["success"] = result.returncode == 0 or idempotent_info["is_idempotent"]
        
        if result.returncode == 0 or idempotent_info["is_idempotent"]:
            # Success or idempotent (already in desired state)
            if idempotent_info["is_idempotent"]:
                response["idempotent"] = True  # Mark as idempotent operation (fixes issue #10)
                response["result"] = idempotent_info.get("message", output) if output else "Operation already in desired state"
            else:
                response["result"] = output if output else "Command completed successfully"
            return response
        else:
            # Non-zero return code: enhance error messages with context (fixes issue #6, #9)
            response["error_code"] = f"COMMAND_FAILED_{result.returncode}"  # Structured error code for automation
            if output:
                response["result"] = output
                # Add error analysis for common patterns
                error_hints = _analyze_error(result.stderr, command_str, cwd)
                if error_hints:
                    response["error_hints"] = error_hints
                return response
            else:
                # No output but command failed - provide context
                error_msg = f"Command failed with return code {result.returncode} (no output)"
                if cwd:
                    error_msg += f" in directory: {cwd}"
                response["error"] = error_msg
                response["return_code"] = result.returncode  # Always include return_code
                response["command_context"] = {
                    "command": command_str,
                    "cwd": cwd,
                    "args_received": args
                }
                return response
        
    except subprocess.TimeoutExpired:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "gh [command]"
        return {
            "success": False,
            "error": f"Command timed out after 30 seconds",
            "error_code": "TIMEOUT",
            "command": command_str,
            "error_type": "timeout",
            "suggestion": "The command may be waiting for input or taking too long. Try using --non-interactive flag or check network connectivity."
        }
    except Exception as e:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "gh [command]"
        return {
            "success": False,
            "error": f"Command execution failed: {str(e)}",
            "error_code": "EXECUTION_ERROR",
            "command": command_str,
            "error_type": "execution_error",
            "command_context": {
                "args_received": args,
                "cwd": cwd
            }
        }


def _check_idempotency(result: subprocess.CompletedProcess, command: str) -> Dict[str, Any]:
    """Check if command result represents an idempotent scenario (fixes issue #10)."""
    # Combine stdout and stderr for analysis
    output_text = ""
    if result.stdout:
        output_text += result.stdout.lower()
    if result.stderr:
        output_text += " " + result.stderr.lower()
    
    # Common idempotent patterns
    idempotent_patterns = [
        ("already closed", "Issue is already closed"),
        ("already exists", "Resource already exists"),
        ("already open", "Issue is already open"),
        ("no changes", "No changes to apply"),
        ("nothing to", "Nothing to do"),
    ]
    
    for pattern, message in idempotent_patterns:
        if pattern in output_text:
            return {
                "is_idempotent": True,
                "message": message,
                "pattern": pattern
            }
    
    return {"is_idempotent": False}


def _analyze_error(stderr: str, command: str, cwd: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """Analyze stderr for common error patterns and provide helpful hints (fixes issue #6)."""
    if not stderr:
        return None
    
    hints = {}
    stderr_lower = stderr.lower()
    
    # Git repository errors
    if "not a git repository" in stderr_lower or "fatal: not a git repository" in stderr_lower:
        hints["error_type"] = "git_repository_error"
        suggestions = ["Ensure you're in a git repository directory"]
        if cwd:
            suggestions.append(f"Current directory: {cwd}")
        else:
            suggestions.append("Consider using --cwd flag to specify the repository directory")
        hints["suggestions"] = suggestions
    
    # Commit/ref errors
    elif "no commit found" in stderr_lower or "could not resolve" in stderr_lower:
        hints["error_type"] = "reference_error"
        hints["suggestions"] = [
            "Check that the branch, tag, or commit reference exists",
            "Verify the reference name is correct"
        ]
    
    # Repository not found errors
    elif "repository not found" in stderr_lower or "not found" in stderr_lower:
        hints["error_type"] = "repository_error"
        hints["suggestions"] = [
            "Verify the repository name is correct",
            "Check that you have access to the repository",
            "Ensure you're authenticated (run 'gh auth status')"
        ]
    
    # Argument errors
    elif "accepts" in stderr_lower and "arg(s)" in stderr_lower and "received" in stderr_lower:
        hints["error_type"] = "argument_error"
        hints["suggestions"] = [
            "Check that all arguments are properly quoted",
            "Multi-word arguments should be in quotes: --body \"text with spaces\"",
            "Use --body-file for multi-line content"
        ]
    
    # Authentication errors
    elif "authentication" in stderr_lower or "unauthorized" in stderr_lower or "not authenticated" in stderr_lower:
        hints["error_type"] = "authentication_error"
        hints["suggestions"] = [
            "Run 'gh auth login' to authenticate",
            "Check authentication status with 'gh auth status'"
        ]
    
    # Permission errors
    elif "permission denied" in stderr_lower or "forbidden" in stderr_lower:
        hints["error_type"] = "permission_error"
        hints["suggestions"] = [
            "Check that you have the necessary permissions",
            "Verify repository access rights"
        ]
    
    if hints:
        return hints
    return None


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {
        "plugin": {
            "name": "gh",
            "version": "1.0.0",
            "description": "Auto-generated plugin for gh command"
        },
        "commands": [
            {
                "name": "run",
                "description": "Execute the gh command",
                "parameters": [
                    {
                        "name": "command",
                        "type": "string",
                        "description": "COMMAND argument",
                        "required": False,
                        "default": None
                    },
                    {
                        "name": "subcommand",
                        "type": "string",
                        "description": "SUBCOMMAND argument",
                        "required": False,
                        "default": None
                    }
                ]
            }
        ]
    }


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="gh Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the gh command

Examples:
  python cli.py run --command <value> --subcommand <value>
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute gh command")
    run_parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Show what would be executed without running")
    run_parser.add_argument("--non-interactive", action="store_true", dest="non_interactive", help="Automatically add --yes flag for non-interactive execution")
    run_parser.add_argument("--cwd", dest="cwd", help="Change working directory for command execution")
    pass
    run_parser.add_argument("--command", dest="arg_command", help="COMMAND argument")
    run_parser.add_argument("--subcommand", dest="arg_subcommand", help="SUBCOMMAND argument")
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Check for dry-run, non-interactive, and cwd flags
            dry_run = getattr(args, 'dry_run', False)
            non_interactive = getattr(args, 'non_interactive', False)
            cwd = getattr(args, 'cwd', None)
            
            # Convert argparse args to dict for run function
            run_args = {}
            if hasattr(args, "arg_command") and args.arg_command is not None:
                run_args["command"] = args.arg_command
            if hasattr(args, "arg_subcommand") and args.arg_subcommand is not None:
                run_args["subcommand"] = args.arg_subcommand
            # Always call run, even with no args (to show gh help)
            result = run(run_args, dry_run=dry_run, non_interactive=non_interactive, cwd=cwd)
        else:
            result = {"error": f"Unknown command: {args.command}"}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)


if __name__ == "__main__":
    main()
