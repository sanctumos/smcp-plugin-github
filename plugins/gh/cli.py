#!/usr/bin/env python3
"""
gh Plugin

Auto-generated plugin for gh command.
Generated by Universal Command Wrapper (UCW).
"""

import argparse
import json
import os
import shlex
import subprocess
import sys
import tempfile
import time
from typing import Dict, Any, Optional, List, Tuple


def run(args: Dict[str, Any], dry_run: bool = False, non_interactive: bool = False, cwd: Optional[str] = None) -> Dict[str, Any]:
    """Execute the gh command."""
    temp_files = []  # Track temp files for cleanup (fixes issue #12)
    try:
        # Validate working directory if specified (fixes issue #3, #9)
        if cwd is not None:
            if not os.path.isdir(cwd):
                return {
                    "success": False,
                    "error": f"Working directory does not exist: {cwd}",
                    "error_code": "INVALID_CWD"
                }
            cwd = os.path.abspath(cwd)
        
        # Build command arguments
        cmd_args = ["gh"]
        pass
        if args.get("command") is not None:
            value = args["command"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        if args.get("subcommand") is not None:
            value = args["subcommand"]
            if isinstance(value, str) and " " in value:
                # Use shlex.split to properly handle quoted strings
                # This preserves multi-word arguments in quotes as single arguments
                cmd_args.extend(shlex.split(value))
            else:
                cmd_args.append(str(value))
        
        # Handle --body arguments with multi-line markdown content (fixes issue #12)
        # Convert --body with newlines to --body-file to preserve markdown formatting
        cmd_args, temp_files = _handle_body_arguments(cmd_args, cwd, dry_run)
        
        # Add --yes flag for non-interactive mode (fixes issue #2)
        if non_interactive and "--yes" not in cmd_args and "-y" not in cmd_args:
            cmd_args.append("--yes")
        
        # Dry run mode: return what would be executed without running
        if dry_run:
            result = {
                "dry_run": True,
                "command": " ".join(cmd_args),
                "cmd_args": cmd_args,
                "args_received": args,
                "cwd": cwd
            }
            # Include temp file info in dry run if any were created
            # Note: In dry_run mode, temp files are NOT cleaned up so tests can verify them
            if temp_files:
                result["temp_files"] = temp_files
            # Clear temp_files list so finally block doesn't clean them up in dry_run
            temp_files_for_cleanup = temp_files
            temp_files = []
            return result
        
        # Execute command
        start_time = time.time()
        result = subprocess.run(
            cmd_args,
            capture_output=True,
            text=True,
            timeout=30,
            cwd=cwd
        )
        elapsed = time.time() - start_time
        
        # Return result in SMCP-compatible format
        # Always pass through output (stdout and/or stderr) regardless of return code
        # This allows commands like 'git' and 'gh' to show help even with non-zero exit codes
        # Combine stdout and stderr for complete output visibility
        output_parts = []
        if result.stdout:
            output_parts.append(result.stdout)
        if result.stderr:
            output_parts.append(result.stderr)
        output = '\n'.join(output_parts) if output_parts else ''
        
        # Build command string for error context (fixes issue #6)
        command_str = " ".join(cmd_args)
        
        # Always include both stdout and stderr in response for debugging
        response = {
            "command": command_str,
            "cmd_args": cmd_args,  # Include for debugging and testing (fixes issue #12)
            "return_code": result.returncode,
            "elapsed": elapsed
        }
        
        if result.stdout:
            response["stdout"] = result.stdout
        if result.stderr:
            response["stderr"] = result.stderr
        
        # Check for idempotent scenarios (fixes issue #10)
        idempotent_info = _check_idempotency(result, command_str)
        
        # Standardize response format (fixes issue #9)
        response["success"] = result.returncode == 0 or idempotent_info["is_idempotent"]
        
        if result.returncode == 0 or idempotent_info["is_idempotent"]:
            # Success or idempotent (already in desired state)
            if idempotent_info["is_idempotent"]:
                response["idempotent"] = True  # Mark as idempotent operation (fixes issue #10)
                response["result"] = idempotent_info.get("message", output) if output else "Operation already in desired state"
            else:
                response["result"] = output if output else "Command completed successfully"
            return response
        else:
            # Non-zero return code: enhance error messages with context (fixes issue #6, #9)
            response["error_code"] = f"COMMAND_FAILED_{result.returncode}"  # Structured error code for automation
            if output:
                response["result"] = output
                # Add error analysis for common patterns
                error_hints = _analyze_error(result.stderr, command_str, cwd)
                if error_hints:
                    response["error_hints"] = error_hints
                return response
            else:
                # No output but command failed - provide context
                error_msg = f"Command failed with return code {result.returncode} (no output)"
                if cwd:
                    error_msg += f" in directory: {cwd}"
                response["error"] = error_msg
                response["return_code"] = result.returncode  # Always include return_code
                response["command_context"] = {
                    "command": command_str,
                    "cwd": cwd,
                    "args_received": args
                }
                return response
        
    except subprocess.TimeoutExpired:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "gh [command]"
        return {
            "success": False,
            "error": f"Command timed out after 30 seconds",
            "error_code": "TIMEOUT",
            "command": command_str,
            "error_type": "timeout",
            "suggestion": "The command may be waiting for input or taking too long. Try using --non-interactive flag or check network connectivity."
        }
    except Exception as e:
        command_str = " ".join(cmd_args) if 'cmd_args' in locals() else "gh [command]"
        return {
            "success": False,
            "error": f"Command execution failed: {str(e)}",
            "error_code": "EXECUTION_ERROR",
            "command": command_str,
            "error_type": "execution_error",
            "command_context": {
                "args_received": args,
                "cwd": cwd
            }
        }
    finally:
        # Clean up temp files (fixes issue #12)
        # Only clean up if not in dry_run mode (dry_run temp files are left for test verification)
        if not dry_run:
            for temp_file in temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.remove(temp_file)
                except Exception:
                    pass  # Ignore cleanup errors


def _handle_body_arguments(cmd_args: List[str], cwd: Optional[str] = None, dry_run: bool = False) -> Tuple[List[str], List[str]]:
    """
    Handle --body arguments with multi-line markdown content by converting to --body-file.
    
    This fixes issue #12 by preserving markdown formatting (newlines, headers, code blocks, etc.)
    that would otherwise be lost or escaped when passed as command-line arguments.
    
    Returns:
        Tuple of (modified_cmd_args, list_of_temp_files_created)
    """
    temp_files = []
    
    # Find --body or -b arguments
    i = 0
    while i < len(cmd_args):
        arg = cmd_args[i]
        
        # Check for --body or -b flag
        if arg in ("--body", "-b"):
            # Get the body content (next argument)
            if i + 1 < len(cmd_args):
                body_content = cmd_args[i + 1]
                
                # Decode escape sequences (e.g., \n, \t) to actual characters (fixes issue #12)
                # This handles cases where content comes in with literal \n instead of actual newlines
                # We need to distinguish between literal "\n" (two chars) and actual newlines
                # Process in order: handle escaped backslashes first, then other escape sequences
                if "\\" in body_content:
                    # First, handle escaped backslashes (\\\\ -> \\) to avoid double-processing
                    # Then handle other escape sequences
                    body_content = body_content.replace("\\\\", "\x00")  # Temporary marker
                    body_content = body_content.replace("\\n", "\n")
                    body_content = body_content.replace("\\t", "\t")
                    body_content = body_content.replace("\\r", "\r")
                    body_content = body_content.replace("\x00", "\\")  # Restore escaped backslashes
                
                # Check if content contains newlines or complex markdown that needs file handling
                # This includes: newlines, code blocks (```), headers (#), lists (-, *), etc.
                needs_file = (
                    "\n" in body_content or
                    "```" in body_content or
                    body_content.strip().startswith("#") or
                    body_content.strip().startswith("-") or
                    body_content.strip().startswith("*") or
                    len(body_content) > 500  # Large content benefits from file handling
                )
                
                if needs_file:
                    try:
                        # Create temporary file with markdown content
                        # Use delete=False so we can control cleanup
                        temp_fd, temp_path = tempfile.mkstemp(suffix=".md", prefix="gh_body_", text=True)
                        
                        try:
                            # Write content to temp file (now with properly decoded newlines)
                            with os.fdopen(temp_fd, 'w', encoding='utf-8') as f:
                                f.write(body_content)
                            
                            # Replace --body "content" with --body-file /path/to/temp/file
                            # Remove the old --body flag and its value
                            cmd_args.pop(i)  # Remove --body or -b
                            cmd_args.pop(i)  # Remove the body content
                            
                            # Insert --body-file and temp file path
                            cmd_args.insert(i, "--body-file")
                            cmd_args.insert(i + 1, temp_path)
                            
                            temp_files.append(temp_path)
                            
                            # Don't increment i since we've already handled this position
                            continue
                        except Exception:
                            # If writing fails, close the file descriptor and remove the file
                            try:
                                os.close(temp_fd)
                                if os.path.exists(temp_path):
                                    os.remove(temp_path)
                            except Exception:
                                pass
                            # Fall through to keep original --body argument
                    except Exception:
                        # If temp file creation fails, keep original --body argument
                        pass
        
        i += 1
    
    return cmd_args, temp_files


def _check_idempotency(result: subprocess.CompletedProcess, command: str) -> Dict[str, Any]:
    """Check if command result represents an idempotent scenario (fixes issue #10)."""
    # Combine stdout and stderr for analysis
    output_text = ""
    if result.stdout:
        output_text += result.stdout.lower()
    if result.stderr:
        output_text += " " + result.stderr.lower()
    
    # Common idempotent patterns
    idempotent_patterns = [
        ("already closed", "Issue is already closed"),
        ("already exists", "Resource already exists"),
        ("already open", "Issue is already open"),
        ("no changes", "No changes to apply"),
        ("nothing to", "Nothing to do"),
    ]
    
    for pattern, message in idempotent_patterns:
        if pattern in output_text:
            return {
                "is_idempotent": True,
                "message": message,
                "pattern": pattern
            }
    
    return {"is_idempotent": False}


def _analyze_error(stderr: str, command: str, cwd: Optional[str] = None) -> Optional[Dict[str, Any]]:
    """Analyze stderr for common error patterns and provide helpful hints (fixes issue #6)."""
    if not stderr:
        return None
    
    hints = {}
    stderr_lower = stderr.lower()
    
    # Git repository errors
    if "not a git repository" in stderr_lower or "fatal: not a git repository" in stderr_lower:
        hints["error_type"] = "git_repository_error"
        suggestions = ["Ensure you're in a git repository directory"]
        if cwd:
            suggestions.append(f"Current directory: {cwd}")
        else:
            suggestions.append("Consider using --cwd flag to specify the repository directory")
        hints["suggestions"] = suggestions
    
    # Commit/ref errors
    elif "no commit found" in stderr_lower or "could not resolve" in stderr_lower:
        hints["error_type"] = "reference_error"
        hints["suggestions"] = [
            "Check that the branch, tag, or commit reference exists",
            "Verify the reference name is correct"
        ]
    
    # Repository not found errors
    elif "repository not found" in stderr_lower or "not found" in stderr_lower:
        hints["error_type"] = "repository_error"
        hints["suggestions"] = [
            "Verify the repository name is correct",
            "Check that you have access to the repository",
            "Ensure you're authenticated (run 'gh auth status')"
        ]
    
    # Argument errors
    elif "accepts" in stderr_lower and "arg(s)" in stderr_lower and "received" in stderr_lower:
        hints["error_type"] = "argument_error"
        hints["suggestions"] = [
            "Check that all arguments are properly quoted",
            "Multi-word arguments should be in quotes: --body \"text with spaces\"",
            "Use --body-file for multi-line content"
        ]
    
    # Authentication errors
    elif "authentication" in stderr_lower or "unauthorized" in stderr_lower or "not authenticated" in stderr_lower:
        hints["error_type"] = "authentication_error"
        hints["suggestions"] = [
            "Run 'gh auth login' to authenticate",
            "Check authentication status with 'gh auth status'"
        ]
    
    # Permission errors
    elif "permission denied" in stderr_lower or "forbidden" in stderr_lower:
        hints["error_type"] = "permission_error"
        hints["suggestions"] = [
            "Check that you have the necessary permissions",
            "Verify repository access rights"
        ]
    
    if hints:
        return hints
    return None


def describe() -> Dict[str, Any]:
    """Return plugin description in SMCP format."""
    return {
        "plugin": {
            "name": "gh",
            "version": "1.0.0",
            "description": "Auto-generated plugin for gh command"
        },
        "commands": [
            {
                "name": "run",
                "description": "Execute the gh command",
                "parameters": [
                    {
                        "name": "command",
                        "type": "string",
                        "description": "COMMAND argument",
                        "required": False,
                        "default": None
                    },
                    {
                        "name": "subcommand",
                        "type": "string",
                        "description": "SUBCOMMAND argument",
                        "required": False,
                        "default": None
                    }
                ]
            }
        ]
    }


def main():
    """Main entry point for the plugin CLI."""
    parser = argparse.ArgumentParser(
        description="gh Plugin - Auto-generated by UCW",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Available commands:
  run    Execute the gh command

Examples:
  python cli.py run --command <value> --subcommand <value>
        """
    )
    
    # Add --describe flag
    parser.add_argument("--describe", action="store_true", help="Output plugin description in JSON format")
    
    subparsers = parser.add_subparsers(dest="command", help="Available commands")
    
    # Run command
    run_parser = subparsers.add_parser("run", help="Execute gh command")
    run_parser.add_argument("--dry-run", action="store_true", dest="dry_run", help="Show what would be executed without running")
    run_parser.add_argument("--non-interactive", action="store_true", dest="non_interactive", help="Automatically add --yes flag for non-interactive execution")
    run_parser.add_argument("--cwd", dest="cwd", help="Change working directory for command execution")
    pass
    run_parser.add_argument("--command", dest="arg_command", help="COMMAND argument")
    run_parser.add_argument("--subcommand", dest="arg_subcommand", help="SUBCOMMAND argument")
    
    args = parser.parse_args()
    
    # Handle --describe flag
    if args.describe:
        print(json.dumps(describe()))
        sys.exit(0)
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    try:
        if args.command == "run":
            # Check for dry-run, non-interactive, and cwd flags
            dry_run = getattr(args, 'dry_run', False)
            non_interactive = getattr(args, 'non_interactive', False)
            cwd = getattr(args, 'cwd', None)
            
            # Convert argparse args to dict for run function
            run_args = {}
            if hasattr(args, "arg_command") and args.arg_command is not None:
                run_args["command"] = args.arg_command
            if hasattr(args, "arg_subcommand") and args.arg_subcommand is not None:
                run_args["subcommand"] = args.arg_subcommand
            # Always call run, even with no args (to show gh help)
            result = run(run_args, dry_run=dry_run, non_interactive=non_interactive, cwd=cwd)
        else:
            result = {"error": f"Unknown command: {args.command}"}
        
        # Output JSON (no indentation for SMCP compatibility)
        print(json.dumps(result))
        sys.exit(0 if "error" not in result else 1)
        
    except Exception as e:
        print(json.dumps({"error": str(e)}))
        sys.exit(1)


if __name__ == "__main__":
    main()
